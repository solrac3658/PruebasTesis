
#include <iostream>
#include <cstdlib>
#include <cassert>
#include <leveldb/db.h>
#include <string>
//#include "md5.h"
//#include "hash-library/keccak.h"
#include <cstdint>

using namespace std;
using namespace leveldb;

void CrearBd(string cuenta){
    
    string name = "Prueba.db";
    DB* db;
    Options options;
    options.create_if_missing = true;
    Status s = DB::Open(options, name, &db);
    assert(s.ok());


}


int main(){

uint256_t hash1, f_hash;

DB* db;
Options options;
options.create_if_missing = true;
Status s = DB::Open(options, "prueba.db", &db);
assert(s.ok());
string s = "0x608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600181905550610246806100686000396000f300608060405260043610610057576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806311713df21461005c57806341c0e1b51461008757806393e84cd91461009e575b600080fd5b34801561006857600080fd5b506100716100a8565b6040518082815260200191505060405180910390f35b34801561009357600080fd5b5061009c6100b2565b005b6100a6610147565b005b6000600154905090565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561010d57600080fd5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16ff5b670de0b6b3a76400003414151561015d57600080fd5b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f193505050501580156101c4573d6000803e3d6000fd5b50600180600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fa75916785ed274ade409b333cb54e33f4d515761c89b45c54ba3d9d944b109c960405160405180910390a25600a165627a7a72305820cc407087701b513237584fca8eaef984eb2d5cdc4fb55ec2d7d33a1f83e9f5480029";
SHA256_CTX ctx;
	SHA256_Init(&ctx);
	SHA256_Update(&ctx, s.c_str(), (sizeof(char) * s.size()) - 1);	
	uint256_t hash1, f_hash;
	SHA256_Final((unsigned char*)&hash1, &ctx);
	SHA256((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&f_hash);
	cout << f_hash.ToString() << endl;


//uint8_t valor[686] = {0x60, 0x80, 0x60, 0x40, 0x52, 0x34, 0x80, 0x15, 0x61, 0x00, 0x10, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x33, 0x60, 0x00, 0x80, 0x61, 0x01, 0x00, 0x0a, 0x81, 0x54, 0x81, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x19, 0x16, 0x90, 0x83, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x02, 0x17, 0x90, 0x55, 0x50, 0x60, 0x00, 0x60, 0x01, 0x81, 0x90, 0x55, 0x50, 0x61, 0x02, 0x46, 0x80, 0x61, 0x00, 0x68, 0x60, 0x00, 0x39, 0x60, 0x00, 0xf3, 0x00, 0x60, 0x80, 0x60, 0x40, 0x52, 0x60, 0x04, 0x36, 0x10, 0x61, 0x00, 0x57, 0x57, 0x60, 0x00, 0x35, 0x7c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x04, 0x63, 0xff, 0xff, 0xff, 0xff, 0x16, 0x80, 0x63, 0x11, 0x71, 0x3d, 0xf2, 0x14, 0x61, 0x00, 0x5c, 0x57, 0x80, 0x63, 0x41, 0xc0, 0xe1, 0xb5, 0x14, 0x61, 0x00, 0x87, 0x57, 0x80, 0x63, 0x93, 0xe8, 0x4c, 0xd9, 0x14, 0x61, 0x00, 0x9e, 0x57, 0x5b, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x34, 0x80, 0x15, 0x61, 0x00, 0x68, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x61, 0x00, 0x71, 0x61, 0x00, 0xa8, 0x56, 0x5b, 0x60, 0x40, 0x51, 0x80, 0x82, 0x81, 0x52, 0x60, 0x20, 0x01, 0x91, 0x50, 0x50, 0x60, 0x40, 0x51, 0x80, 0x91, 0x03, 0x90, 0xf3, 0x5b, 0x34, 0x80, 0x15, 0x61, 0x00, 0x93, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x61, 0x00, 0x9c, 0x61, 0x00, 0xb2, 0x56, 0x5b, 0x00, 0x5b, 0x61, 0x00, 0xa6, 0x61, 0x01, 0x47, 0x56, 0x5b, 0x00, 0x5b, 0x60, 0x00, 0x60, 0x01, 0x54, 0x90, 0x50, 0x90, 0x56, 0x5b, 0x60, 0x00, 0x80, 0x90, 0x54, 0x90, 0x61, 0x01, 0x00, 0x0a, 0x90, 0x04, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x33, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x14, 0x15, 0x15, 0x61, 0x01, 0x0d, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x60, 0x00, 0x80, 0x90, 0x54, 0x90, 0x61, 0x01, 0x00, 0x0a, 0x90, 0x04, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0xff, 0x5b, 0x67, 0x0d, 0xe0, 0xb6, 0xb3, 0xa7, 0x64, 0x00, 0x00, 0x34, 0x14, 0x15, 0x15, 0x61, 0x01, 0x5d, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x60, 0x00, 0x80, 0x90, 0x54, 0x90, 0x61, 0x01, 0x00, 0x0a, 0x90, 0x04, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x61, 0x08, 0xfc, 0x34, 0x90, 0x81, 0x15, 0x02, 0x90, 0x60, 0x40, 0x51, 0x60, 0x00, 0x60, 0x40, 0x51, 0x80, 0x83, 0x03, 0x81, 0x85, 0x88, 0x88, 0xf1, 0x93, 0x50, 0x50, 0x50, 0x50, 0x15, 0x80, 0x15, 0x61, 0x01, 0xc4, 0x57, 0x3d, 0x60, 0x00, 0x80, 0x3e, 0x3d, 0x60, 0x00, 0xfd, 0x5b, 0x50, 0x60, 0x01, 0x80, 0x60, 0x00, 0x82, 0x82, 0x54, 0x01, 0x92, 0x50, 0x50, 0x81, 0x90, 0x55, 0x50, 0x33, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x7f, 0xa7, 0x59, 0x16, 0x78, 0x5e, 0xd2, 0x74, 0xad, 0xe4, 0x09, 0xb3, 0x33, 0xcb, 0x54, 0xe3, 0x3f, 0x4d, 0x51, 0x57, 0x61, 0xc8, 0x9b, 0x45, 0xc5, 0x4b, 0xa3, 0xd9, 0xd9, 0x44, 0xb1, 0x09, 0xc9, 0x60, 0x40, 0x51, 0x60, 0x40, 0x51, 0x80, 0x91, 0x03, 0x90, 0xa2, 0x56, 0x00, 0xa1, 0x65, 0x62, 0x7a, 0x7a, 0x72, 0x30, 0x58, 0x20, 0xcc, 0x40, 0x70, 0x87, 0x70, 0x1b, 0x51, 0x32, 0x37, 0x58, 0x4f, 0xca, 0x8e, 0xae, 0xf9, 0x84, 0xeb, 0x2d, 0x5c, 0xdc, 0x4f, 0xb5, 0x5e, 0xc2, 0xd7, 0xd3, 0x3a, 0x1f, 0x83, 0xe9, 0xf5, 0x48, 0x00, 0x29};
//Slice s1 = const_cast<const uint8_t *>(valor);
/*string valore, valora;
string key = keccak(valor.c_str(), valor.size());
uint8_t arr = 2;

if (s.ok()) cout << s.ToString() << endl;

//if (s.ok()) s = db->Put(WriteOptions(), key, valor);

 s = db->Get(ReadOptions(), key, &valore);
  s = db->Get(ReadOptions(), "1", &valora);

/*cout << " con la clave " <<  md5(valore) << "el resultado es : " << valore << endl;
cout << " con la clave 1 " << "el resultado es : " << valora << endl<< endl;

//cout << " con la clave " <<  keccak(valor.c_str(), valor.size()) << "el resultado es : " << valore << endl;
cout << (valor.size() - 2) / 2;
uint8_t * prueba = new uint8_t[(valor.size() - 2) / 2];

char x[3];
char **y;

for (int i = 0, j = 2; (i < (valor.size() - 2) / 2) && (j < valor.size()); i++, j += 2) {
	memset(x, '\0', sizeof(char) * 3);
//	cout << valor[j] << valor[j + 1];
	x[0] = valor[j];
	x[1] = valor[j + 1];

	prueba[i] = static_cast<uint8_t>(strtol(x, NULL, 16));
	//assert(**y = '\0');
	//cout << prueba[i] << endl;
}

assert(key == keccak(valore.c_str(), valore.size()));*/

	return 0;
}
